정규화
    데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정
    데이터 중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법
    정규화를 수행하면 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화 할 수 있다.
    정규화는 제1정규화부터 제5정규화까지 있지만, 실질적으로는 제3정규화까지만 수행한다.

제1 정규화
    정규화는 함수적 종속성을 근거로 한다.
        함수정 종속성 : X -> Y이면 Y는 X에 함수적으로 종속됨
            예) 회원ID가 변화하면 이름도 변경됨
                회원ID : 기본키
                회원ID가 이름을 함수적으로 종속함
                어떤 컬럼이 다른 컬럼을 종속할때 기본키로 등록한다 (함수적 종속성을 근거로)
    기본키를 잡는 것이 제1정규화 아직 분해 안함

제2 정규화
    부분 함수 종속성은 기본키가 2개 이상의 칼럼으로 이루어진 경우에 발생한다.
    제1 정규화에서 기본키를 함수적 종속성에 의해 선정했으면 기본키가 만약 2개 이상일 경우
    테이블을 분해 한다. 이때 기본키가 하나면 제2 정규화는 스킵

제3 정규화
    이행 함수 종속성을 제거한다.
        이행 함수 종속성 : 기본키를 제외하고 칼럼 간에 종속성이 발생하는 것
        관리점 코드랑 관리점명이 칼럼에 있으면 관리점 코드를 변경하면 관리점명도 바뀐다
        이는 함수 종속성이 있는것 관리점코드만 남기고 테이블을 분해하여 관리점 테이블은 만든다


정규화 예제 (항상 중복을 먼저 찾아라)

제1차 정규화: 컬럼간의 중복 데이터를 제거하고, 복수의 값을 분리하여 각 컬럼이 원자적인 값을 가지도록 하는 과정입니다.
제2차 정규화: 부분 함수 종속성을 찾아 기본 키로 설정하는 단계입니다. 비-키 속성이 기본 키의 일부에만 종속되어 있는 경우, 이를 별도의 테이블로 분리하여 기본 키에 완전 종속되도록 합니다.
제3차 정규화: 기본 키 외의 일반 컬럼에서의 이행 함수 종속성 관계를 찾아 분리하는 단계입니다. 일반 컬럼 간에 종속성이 이행적으로 발생하는 경우, 이를 분리하여 별도의 테이블로 만들어줍니다.

정규화의 성능

정규화의 문제점
    정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다
    정규화는 데이터 SELECT 조회시에 JOIN을 유발하기 때문에 CPU와 메모리를 많이 사용한다.

    정규화의 문제점을 해결하기 위해서 반정규화를 하여 하나의 테이블에 저장한다면 JOIN을 통한 성능저하를 해결한다


반정규화
    데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법
    반정규화는 조회 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.

반정규화를 수행하는 겨웅
    정규화에 충실하면 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
    다량의 범위를 자주 처리해야 하는 경우
    특정 범위의 데이터만 자주 처리하는 경우
    요약/집계정보가 자주 요구되는 경우

반정규화 절차
    대상 조사 및 검토 : 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상을 조사한다.
    다른 방법 검토 : 반정규화를 수행하기 전에 다른 방법이 있는지 검토한다.
        예) 클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션 등을 검토
        클러스터링 인덱스 : 인덱스 정보를 저장할 떄 물리적으로 정렬해서 저장하는 방법
        따라서 조회 시에 인접 블록을 연속적으로 일긱 때문에 성능이 향상된다.
    반정규화 수행 : 테이블 속성 관계 등을 반정규화 한다.

반정규화 기법
    1. 계산된 칼럼 추가
    2. 테이블 수직분할
        하나의 테이블을 2개 이상의 테이블로 분할한다. 칼럼의 속성명으로 분할

    3.테이블 수평분할
        하나의 테이블에 있는 값을 기준으로 테이블을 분할한다 칼럼의 값으로 분할

        파티션 기법
            데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있다.
            파티션을 사용하면 논리적으로는 하나의 테이블이지만, 여러 개의 데이터 파일에 분산되어서 저장된다.
            종류 :
                Range Partition : 데이터 값의 범위를 기준으로 파티션 수행
                List Partition : 특정한 값을 지정하여 파티션 수행
                Hash Partition : 해시 함수를 적용하여 파티션 수행
                Composite Partition : 범위와 해시를 사용하여 파티션 수행
            장점 :
                데이터 조회시에 엑세스 범위를 기준으로 파티션을 수행한다.
                데이터가 분할되어 있기 때문에 I/O의 성능이 향상된다.
                각 파티션을 독립적으로 백업 및 복구가 가능한다.

        4. 테이블 병합
            1대 1 관계의 테이블을 하나의 테이블로 병합해서 성능을 향상시킨다.
            1대 N관계의 테이블을 병합하여 성능을 향상시킨다.
                이는 많은 양의 데이터 중복이 발생한다

분산 데이터베이스
    중앙 집중형 데이터베이스 :
        데이터베이스 시스템 구축시, 1대의 물리적 시스템에 데이터베이스 관리 시스템을 설치
        여러 명의 사용자가 데이터 베이스 관리 시스템에 접속하여 데이터베이스를 사용하는 구조
    분산 데이터베이스 :
        물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고,
        분산된 작업 처리를 수행하는 데이터베이스
            분산 데이터베이스를 사용하는 고객은 시스템이 내부적으로 분산되어 있는지의 여부를 인식하지
            못하면서, 자신만의 데이터베이스를 사용하는 것처럼 사용할 수 있다.

        분산 데이터베이스의 투명성
            분할 투명성 : 고객은 분할 되있는 것을 느낄 필요가 없다
            위치 투명성 : 고객이 어느 위치에 있어도 동일한 명령으로 접근할 수 있어야 한다.
            지역 사상 투명성 : 각 지역 시스템 이름과 무관한 이름이 사용 가능하다.
            중복 투명성 : 데이터베이스 객체가 여러 시스템에 중복되어 존재해도 고객과는 무관하게 일관성 유지
            장애 투명성 : 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성 보장
            병행 투명성 : 여러 고객이 동시에 트랜잭션을 수행하는 경우에도 결과에 이상이 없어야 한다.

    장점 :
        1. 데이터베이스의 신뢰성과 가용성이 높다
        2. 병렬 처리를 수행하기 때문에 빠른 응답이 가능하다.
        3. 분산 데이터베이스를 추가하여 시스템 용량 확장이 쉽다.

    단점 :
        1. 분리 되어 있으므로 관리와 통제가 어렵다.
        2. 보안관리가 어렵다.
        3. 데이터 무결성 관리가 어렵다.
        4. 데이터베이스 설계가 복잡하다.
