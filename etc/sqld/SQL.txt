집합연산
UNION 두 테이블의 중복을 제거한 합집합
UNION ALL 두 테이블의 중복을 제거하지 않은 합집합
INTERSECT 두 테이블의 교집합 AND
EXPECT 두 테이블의 차집합
EXPECT는 먼저 나열된 (테이블1) - (테이블2) 의 연산이 적용되므로 순서가 중요한 차집합
EXPECT를 제외한 집합연산은 테이블의 순서를 바꿔도 같은 결과 반환

VIEW는 자주쓰는 SELECT절을 데이터 저장해놓는 것 실제 데이터가 존재하지 않는다.
DBMS는 쿼리에서 VIEW를 발견시 저장된 SELECT절로 번역해서 해석한다.

이때 번역된 절이 SUBQUERY다 SUB란 하위란 뜻으로 본 쿼리보다 먼저 해석된다
SELECT FROM WHERE절에 모두 쓰일 수 있다
DBMS는 서브쿼리를 해석해 상수로 번역해서 쿼리문을 분석한다.

CASE WHEN 조건 THEN '상수'
     ELSE '상수'
CASE식의 강력한 점은 식이라는 것이다 어디든지 적을 수 있다.
SELECT WHERE GROUP BY HAVING ORDER BY 어디서든 가능하다.

윈도우함수
데이터를 가공하게 해주며 성능과 연관이 아주 깊다 (자주 쓰이는 굉장히 중요한 기능)
집약기능이 없는 자르기만하는 group by\
group by는 해당 칼럼의 데이터 수 만큼 row가 집약되는데
윈도우함수는 집약기능이 없어 테이블의 레코드 수와 같다.

작성하는 곳은 select절만 한다
집약함수 뒤에 over(partion by 칼럼 ) 또는 order by 칼럼

조건분기에 UNION을 사용하는 경우가 있는데
조건이 다른 2개테이블을 UNION으로 합치는 방법.
이경우 실행계획을 보면 테이블을 2개 조회하고 일단 QUERY절이 너무 길어지는 단점
정확한 판단 없이 SELECT 구문 전체를 여러 번 사요애서 코드를 길게 맘ㄴ드는 것은 쓸데 없는
테이블 접근을 발생시키며 SQL의 성능을 나쁘게 합니다.

CASE 식을 사용하면 조건분기를 쉽게 해결할 수도 있다.
조건절을 WHERE절에 쓰면 초보자다 - 격언 ㅋㅋㅋ
SELECT절로도 충분하다 SELECT나 WHERE절같은'구문'에서 CASE같은 '식'으로 사고를 변경하는 것이
SQL을 마스터하는 열쇠!

항상 조건이 따라오면 IF문으로 어떻게 해야할지 먼저 생각


UNION을 조건분기로 사용할떄 성능상 좋을 경우가 있는데 이는 WHERE절을 사용할떄 인덱스가 있는 컬럼일 경우
UNION을 사용하지 않는 SELECT절에서 인덱스를 사용하지못하고 풀스캔할경우
풀스캔1회보다 인덱스스캔3회가 더 빠를수 있다.
WHERE 절에서 OR은 인덱스를 사용할 수 없다.

SQL의 성능은 저장소의 I/O를 얼마나 감소시킬수 있을지가 열쇠 -> 디스크에 엑세스를 최소화하고
캐시메모리로 해결해야함 -> 캐시히트율이 높아야함
캐시히트율이란 필요한 데이터가 100개인데 그중 몇개를 캐시에서 가져오는지
UNION에서 조건분기를 최대한 자제하자 CASE로 해결이 거의다 됨

집약합수 -> COUNT, SUM, MAX, MIN, AVG
여러개의 레코드를 한 개의 레코드로 집약한다

GROUP BY를 썼을 경우 셀렉트절에 올수 있는 구는 상수, GROUP BY 구에서 사용한 집약 키, 집약 함수
MYSQL에선 칼럼도 출력되긴 하지만 ANSI표준이 아님.



